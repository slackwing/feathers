<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>The Violin</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Georgia, serif;
        background-color: #f5f5f5;
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .page {
        width: 90%;
        max-width: 600px;
        aspect-ratio: 6 / 9;
        background: white;
        border: 1px solid #ccc;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 40px;
        padding: 60px 50px;
        box-sizing: border-box;
        position: relative;
        overflow: hidden;
      }

      .page-content {
        font-size: 16px;
        line-height: 1.6;
        text-align: justify;
      }

      .page-content p {
        margin: 0;
        text-indent: 2em;
      }

      .page-content p:first-of-type,
      .page-content .story-title + p {
        text-indent: 0;
      }

      .page-number {
        position: absolute;
        bottom: 40px;
        right: 50px;
        font-size: 14px;
        color: inherit;
      }

      .story-title {
        text-align: center;
        font-size: 24px;
        font-weight: normal;
        margin-bottom: 40px;
        font-style: italic;
      }

      .story-source {
        display: none;
      }

      @media (max-width: 768px) {
        .page {
          width: 95%;
          padding: 40px 30px;
        }

        .page-content {
          font-size: 14px;
        }

        .page-number {
          bottom: 20px;
          right: 30px;
        }
      }
    </style>
  </head>

  <body>
    <!-- Hidden source content -->
    <div class="story-source" id="story-source">
      <h1 class="story-title">The Violin</h1>
      <p>
        In the breath before the bow met string, she—and I—had to achieve
        zen-like emptiness, and simultaneously, a spotless memory. Flawless
        wasn't enough—it had to appear effortless. "I'm a fraud," my player
        thought despite success, "Not half as good as they believe. One
        polished act is all they see." Yes, I can hear the thoughts of my
        player, and others nearby, but only if they resonate with my own. You
        see I'm also not half as good as my player believes—I myself am a
        fraud.
      </p>
      <p>
        I came to as I was tuned in 1963, in Erlangen, Germany. The late war
        never reached the town's wide but quiet streets, its thoughtful open
        squares, all built by French refugees. Front cut of Alpine spruce and
        flamed maple back, I was an imitation of a renowned predecessor
        crafted in 1914. I passed through several masters and emigrated across
        the Atlantic, where for the first time I was placed in the hands of a
        young student. But one month prior the dealer had replaced the label
        inside of me. I sold for more than double my worth, now reading "Ernst
        Heinrich Roth, Bubenreuth / Erlangen, anno 1914."
      </p>
      <p>
        Later I came to learn the exploited parents were already in poor
        financial standing—convinced by teachers that a lesser instrument
        would stunt their young prodigy. The girl vowed, "I won't disappoint
        them," I the same to her, and since then we worked tirelessly.
      </p>
      <p>
        The auditorium at Julliard was frigid but you could smell the heat of
        the spotlights. A row of judges sat mute. Our opening breath wasn't
        out of sync, but trembled. We held together through the swells and
        lulls of Mendelssohn's Concerto in E. But approaching the cadenza I
        overthought a measure we'd only played by muscle memory. The zen—a
        precarious lucid dream—unraveled; I grasped a C# too tight; the girl
        stumbled. The dream was over. When numbness subsided, I was on the
        girl's bed. I thought, "It's all my fault." "It's all my fault," she
        echoed unexpectedly. "They fight because we have no money. They have
        no money because of me." I was startled. Did my thoughts resonate
        into... Fear spread through my grain. All this time, was it my own...
        Thankfully the girl played no more, though she brought me along to
        university. I willingly hid underneath her bunk, out of sight and
        relieved to influence her no longer.
      </p>
      <p>
        Years later the girl began life in the city and was badly in need of
        money. I was taken to a shop on 57th street and left to be appraised.
        Finally, I thought, the truth would come out and the girl could be rid
        of me. A few days later the girl returned, and the appraiser shared
        the expected news that I wasn't actually the famed 1914. E. H. Roth
        didn't move to Erlangen until 1953. Having prepared for this moment, I
        took one last look at the little girl whose face never aged for me.
        But she said, "I think I'd like to keep it then, after all." A
        yearning rose up in me—I'd desperately wanted to be kept. She packed
        me up with usual care and we rode the subway home, lighter, quietly
        reflecting.
      </p>
      <p>
        The days as usual grew long then short but in a different key. Beneath
        her bed the cats hide and sleep, whispering and keeping me company.
        Every now and then she takes me out to play a nostalgic tune,
        untroubled by mistakes. Each time we move apartments she carries me
        last, sitting me beside her in the front seat.
      </p>
    </div>

    <!-- Pages will be generated here -->
    <div id="pages-container"></div>

    <script>
      function paginateStory() {
        const source = document.getElementById('story-source');
        const container = document.getElementById('pages-container');

        const title = source.querySelector('.story-title');
        const paragraphs = Array.from(source.querySelectorAll('p'));

        // Calculate line height from a test paragraph
        const testDiv = document.createElement('div');
        testDiv.className = 'page-content';
        testDiv.style.visibility = 'hidden';
        testDiv.style.position = 'absolute';
        testDiv.innerHTML = '<p>Test line for measuring</p>';
        document.body.appendChild(testDiv);

        const lineHeight = parseFloat(window.getComputedStyle(testDiv.querySelector('p')).lineHeight);
        document.body.removeChild(testDiv);

        // Calculate page dimensions manually - using standard 6x9 paperback ratio
        const containerWidth = container.clientWidth || window.innerWidth * 0.9;
        const pageWidth = Math.min(containerWidth * 0.9, 600);
        const pageHeight = pageWidth * (9 / 6); // 6x9 paperback aspect ratio

        const padding = 120; // top + bottom padding
        const bottomMargin = 150; // space for page number - very generous
        const availableHeight = pageHeight - padding - bottomMargin;
        const maxLines = Math.floor(availableHeight / lineHeight); // Use actual calculation

        // But cap it at a reasonable max to be safe
        const cappedMaxLines = Math.min(maxLines, 29);

        console.log('Page width:', pageWidth, 'Page height:', pageHeight, 'Line height:', lineHeight, 'Calculated lines:', maxLines, 'Capped at:', cappedMaxLines);

        if (cappedMaxLines <= 0) {
          console.error('Cannot calculate valid maxLines');
          return;
        }

        let pageNumber = 1;
        let currentLines = 0;
        let currentPageContent = [];

        // Add title to first page
        if (title) {
          // Measure actual title height
          const testTitle = title.cloneNode(true);
          const testDiv = document.createElement('div');
          testDiv.className = 'page-content';
          testDiv.style.visibility = 'hidden';
          testDiv.style.position = 'absolute';
          testDiv.style.width = (pageWidth - 100) + 'px';
          testDiv.appendChild(testTitle);
          document.body.appendChild(testDiv);

          const titleHeight = testTitle.clientHeight;
          const titleLines = Math.ceil(titleHeight / lineHeight);

          document.body.removeChild(testDiv);

          currentPageContent.push(title.cloneNode(true));
          currentLines += titleLines;
          console.log('Title uses', titleLines, 'lines');
        }

        // Process each paragraph
        for (let para of paragraphs) {
          const text = para.textContent.trim();
          const words = text.split(/\s+/);

          // Estimate lines in this paragraph by measuring it
          const testP = document.createElement('p');
          testP.className = para.className;
          testP.textContent = text;
          const testDiv = document.createElement('div');
          testDiv.className = 'page-content';
          testDiv.style.visibility = 'hidden';
          testDiv.style.position = 'absolute';
          testDiv.style.width = (pageWidth - 100) + 'px'; // Account for padding
          testDiv.appendChild(testP);
          document.body.appendChild(testDiv);

          const paraHeight = testP.clientHeight;
          const paraLines = Math.ceil(paraHeight / lineHeight);

          document.body.removeChild(testDiv);

          // Check if paragraph fits on current page
          if (currentLines + paraLines <= cappedMaxLines) {
            // Fits completely
            currentPageContent.push(para.cloneNode(true));
            currentLines += paraLines;
          } else if (currentLines === cappedMaxLines - 1) {
            // Only 1 line left - don't start new paragraph, create page
            createPage(currentPageContent, pageNumber++, pageHeight);
            currentPageContent = [para.cloneNode(true)];
            currentLines = paraLines;
          } else if (currentLines + 1 < cappedMaxLines) {
            // Some room left, split the paragraph by measuring actual line breaks
            const linesAvailable = cappedMaxLines - currentLines;

            // Binary search to find how many words fit in the available lines
            // Add current page content to the test to get accurate measurement
            let low = 0;
            let high = words.length;
            let bestFit = 0;

            while (low <= high) {
              const mid = Math.floor((low + high) / 2);
              if (mid === 0) {
                low = mid + 1;
                continue;
              }

              const testText = words.slice(0, mid).join(' ');
              const testP = document.createElement('p');
              testP.textContent = testText;

              const testDiv = document.createElement('div');
              testDiv.className = 'page-content';
              testDiv.style.visibility = 'hidden';
              testDiv.style.position = 'absolute';
              testDiv.style.width = (pageWidth - 100) + 'px';

              // Add existing page content
              currentPageContent.forEach(el => testDiv.appendChild(el.cloneNode(true)));
              testDiv.appendChild(testP);

              document.body.appendChild(testDiv);

              const totalHeight = testDiv.scrollHeight;
              const fitsOnPage = totalHeight <= availableHeight + padding;

              document.body.removeChild(testDiv);

              if (fitsOnPage) {
                bestFit = mid;
                low = mid + 1;
              } else {
                high = mid - 1;
              }
            }

            if (bestFit > 0) {
              const p1 = document.createElement('p');
              p1.textContent = words.slice(0, bestFit).join(' ');
              currentPageContent.push(p1);

              createPage(currentPageContent, pageNumber++, pageHeight);

              const p2 = document.createElement('p');
              p2.textContent = words.slice(bestFit).join(' ');
              currentPageContent = [p2];

              // Measure remaining paragraph lines
              const testDiv2 = document.createElement('div');
              testDiv2.className = 'page-content';
              testDiv2.style.visibility = 'hidden';
              testDiv2.style.position = 'absolute';
              testDiv2.style.width = (pageWidth - 100) + 'px';
              testDiv2.appendChild(p2.cloneNode(true));
              document.body.appendChild(testDiv2);

              const remainingHeight = testDiv2.querySelector('p').clientHeight;
              currentLines = Math.ceil(remainingHeight / lineHeight);

              document.body.removeChild(testDiv2);
            } else {
              // Not enough room, start new page
              createPage(currentPageContent, pageNumber++, pageHeight);
              currentPageContent = [para.cloneNode(true)];
              currentLines = paraLines;
            }
          } else {
            // No room, start new page
            createPage(currentPageContent, pageNumber++, pageHeight);
            currentPageContent = [para.cloneNode(true)];
            currentLines = paraLines;
          }
        }

        // Create final page
        if (currentPageContent.length > 0) {
          createPage(currentPageContent, pageNumber, pageHeight);
        }
      }

      function createPage(elements, pageNumber, height) {
        const container = document.getElementById('pages-container');

        const page = document.createElement('div');
        page.className = 'page';
        // Override the aspect-ratio with explicit height
        page.style.height = height + 'px';

        const content = document.createElement('div');
        content.className = 'page-content';
        elements.forEach(el => content.appendChild(el));

        const pageNum = document.createElement('div');
        pageNum.className = 'page-number';
        pageNum.textContent = pageNumber;

        page.appendChild(content);
        page.appendChild(pageNum);
        container.appendChild(page);
      }

      window.addEventListener('load', paginateStory);
    </script>
  </body>
</html>
