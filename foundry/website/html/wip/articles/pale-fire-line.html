<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,minimum-scale=0.76,initial-scale=0.76,maximum-scale=0.76"
    />
    <title><?php echo $title; ?></title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Cormorant:wght@300;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Lora:wght@400&display=swap"
      rel="stylesheet"
    />
    <script>
      MathJax = {
        tex: {
          inlineMath: [["$", "$"]],
          displayMath: [["$$", "$$"]],
        },
        chtml: {
          scale: 1.2,
        },
        svg: {
          scale: 1.2,
        },
      };
    </script>
    <script
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>
    <style type="text/less">
      body {
        color: rgb(36, 36, 36);
        /*
          font-family: 'Lora', serif;
          font-size: 21px;
          line-height: 1.58;
          */
        font-family: "Cormorant", serif;
        font-weight: 300;
        font-size: 23px;
        line-height: 1.75;

        #container {
          max-width: 740px;
          margin: auto;

          #header {
            font-family: Helvetica, Arial, sans-serif;

            #navigation {
              text-transform: uppercase;
              font-size: 18px;

              a {
                color: rgb(108, 108, 108);
                text-decoration: none;
              }
            }

            #title h1 {
              font-size: 36px;
              font-weight: 100;
            }
          }

          #undertitle {
            h2 {
              margin-top: 43px;
              font-family: Helvetica, Arial, sans-serif;
              font-size: 29px;
              font-weight: 100;
            }
          }

          #metadata {
            font-size: 14px;

            #author-name {
              font-size: 16px;
            }

            #author-email a {
              font-size: 16px;
              color: #1a8917;
            }

            #article-version,
            #article-published,
            #article-updated {
              color: rgb(108, 108, 108);
            }
          }

          #content {
            .intro {
              font-family: Helvetica, Arial, sans-serif;
              font-size: 21px;
            }

            h2 {
              margin-top: 43px;
              font-family: Helvetica, Arial, sans-serif;
              font-size: 29px;
              font-weight: 100;
            }

            blockquote {
              color: rgb(108, 108, 108);
              font-size: 21px;
              padding-left: 23px;
              box-shadow: inset 3px 0 0 -1px rgb(108, 108, 108);
            }
          }
        }
      }

      a {
        color: #3366cc;
        text-decoration: none;
      }

      pre {
        /* padding: 32px; */
        overflow: auto;
        border: 1px solid #e5e5e5;
        white-space: pre;
        font-size: 12px;
      }

      /* Markdown's grave tick styling: */
      p > code {
        font-size: 18px;
      }

      /* https://stackoverflow.com/a/41566570/925913 */
      .cryptedmail:after {
        content: attr(data-name) "@" attr(data-domain) "." attr(data-tld);
      }
    </style>
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/atelier-lakeside-light.min.css"> -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/atelier-savanna-light.min.css"> -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/harmonic16-light.min.css"> -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/horizon-light.min.css"> -->
    <!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/phd.min.css"> -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/unikitty-light.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/mathematica.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <style>
      svg {
        border: solid 1px #666666;
      }
      /* TODO: Customize. */
      .tooltip {
        position: absolute;
        text-align: center;
        width: 80px;
        height: 28px;
        padding: 2px;
        font: 12px sans-serif;
        background: lightsteelblue;
        border: 0px;
        border-radius: 8px;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <div id="header">
        <div id="navigation" style="margin-bottom: 30px">
          <a href="/">Index</a>
        </div>
        <div id="title">
          <h1>Pale Fire.js</h1>
        </div>
      </div>
      <article id="content">
        <div id="force-directed-graph"></div>
        <p>Testing 123. Testing 123. Testing 123.</p>
        <div id="custom-layout-graph"></div>
      </article>
    </div>

    <!-- Javascript that can happen whenever. -->
    <script>
      const SVG_WIDTH = 740;
      const SVG_HEIGHT = 512;

      const NodeType = Object.freeze({
        FOREWORD: 0,
        POEM_CANTO: 1,
        POEM_GROUP: 2,
        POEM_LINE: 3,
        COMMENTARY: 4,
      });
      const ReferenceType = Object.freeze({
        DIRECT: 0,
        INDIRECT: 1,
      });
      class Node {
        constructor(type, id, page, text, lineStart, lineEnd) {
          this.type = type;
          this.id = id;
          // F = Foreword
          // L1-L999 = poem, node per line
          // G1-G1000 = poem, node per group of lines
          // C1-C4 = poem, node per cantos
          // N1-N1000 = commentary, node per note, by starting line
          this.page = page;
          this.text = text;
          this.wordcount = text.split(/\s+/).length;
          // Only applies to commentary nodes.
          this.lineStart = Number(lineStart);
          this.lineEnd = Number(lineEnd);
          // Only applies to non-poem nodes.
          this.direct_references = new Array();
          this.indirect_references = new Array();
          // To be set later.
          this.d3_force_directed_node = null;
          this.d3_custom_layout_node = null;
          this.d3_force_directed_node_selected = null;
          this.d3_custom_layout_node_selected = null;
          this.dfs_ordering = -1;
        }
      }

      function escape(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function sanitize_canto(canto) {
        canto = canto.map((page) =>
          page
            // Remove line numbers in the cantos.
            .replace(/(^|\n)\d+(?= [a-zA-Z0-9-()"])/g, "$1")
            // Consolidate line-wrapped lines with their previous line.
            .replace(/((^|\n) .+)\n(?=[^ ])(.+)/g, "$1$3")
            // Remove double linebreaks.
            .replace(/(^|\n)\s*\n/g, "$1")
            // Remove trailing whitespace.
            .replace(/\s*$/, ""),
        );

        // Consolidate line-wrapped lines from the previous page.
        for (let i = 0; i < canto.length - 1; i++) {
          var match = canto[i + 1].match(/^(?=[^ ])(.*)\n/);
          if (match !== null) {
            canto[i] += match[1];
            canto[i + 1] = canto[i + 1].replace(/(?=[^ ])(.*)\n/, "");
          }
        }

        return canto;
      }
    </script>

    <!-- Javascript that needs to wait for DOM content loaded. -->
    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const svg_force_directed = d3
          .create("svg")
          .attr("width", SVG_WIDTH)
          .attr("height", SVG_HEIGHT);
        // .attr("viewBox", [0, 0, width, height])
        // .attr("style", "width: 100%; height: 512px;");
        document.getElementById("force-directed-graph").append(svg_force_directed.node());
        const zoom = d3.zoom().on("zoom", function () {
          z.attr("transform", d3.zoomTransform(this));
        });
        const z = svg_force_directed.call(zoom).append("g");

        // Process nodes.

        fetch("./pale-fire.json")
          .then((response) => response.json())
          .then((book) => {
            var title = book["title"];
            var foreword = book["foreword"];
            var cantoOne = book["cantoOne"];
            var cantoTwo = book["cantoTwo"];
            var cantoThree = book["cantoThree"];
            var cantoFour = book["cantoFour"];
            var commentary = book["commentary"];
            var index = book["index"];

            foreword = foreword.map((page) => page.replace(/^\d+\s+(FOREWORD\s+)?/, ""));

            cantoOne = sanitize_canto(
              cantoOne.map((page) => page.replace(/^\d+\n(CANTO xxx\n)?/, "")),
            );

            cantoTwo = sanitize_canto(
              cantoTwo.map((page) => page.replace(/^\d+\n(Canto xxx\n)?/, "")),
            );

            cantoThree = sanitize_canto(
              cantoThree.map((page) => page.replace(/^\d+\n(CANTO xxxxx\n)?/, "")),
            );

            cantoFour = sanitize_canto(
              cantoFour.map((page) => page.replace(/^\d+\n(CANTO xxxx\n)?/, "")),
            );

            commentary = commentary.map((page) =>
              page.replace(/^(\d+\s+)?(COMMENTARY|PALE FIRE)(\n\d+)?\s+/, ""),
            );

            let pageNumber;
            let nodeMap = new Map();
            let lineToNodeMap = new Map();
            let poemLines = new Array();
            let poemLineNodes = new Array();
            poemLines.push(null); // Make 1-indexed.
            poemLineNodes.push(null); // Make 1-indexed.
            let poemGroupNodes = new Array();
            let poemCantosNodes = new Array();
            let nonPoemNodes = new Array();
            let commentaryNodes = new Array();
            let node;

            // Foreword.

            pageNumber = 7;
            node = new Node(NodeType.FOREWORD, "F", pageNumber, foreword.join("\n\n"), null, null);
            nodeMap.set(node.id, node);
            nonPoemNodes.push(node);

            // Poem, line-by-line. (Grouping by notes later.)

            pageNumber = 22;
            let lineNumber = 1;
            for (let canto of [cantoOne, cantoTwo, cantoThree, cantoFour]) {
              for (let page of canto) {
                for (let line of page.split(/\s*\n\s*/)) {
                  poemLines.push(line); // Useful later.
                  // For debugging; uncomment to see every line, numbered.
                  // console.log(lineNumber + " " + line);
                  node = new Node(
                    NodeType.POEM_LINE,
                    `L${lineNumber}`,
                    pageNumber,
                    line,
                    lineNumber,
                    null,
                  );
                  poemLineNodes.push(node);
                  lineNumber++;
                }
                pageNumber++;
              }
            }
            console.assert(lineNumber - 1 == 1000);
            console.log("Parsed " + (lineNumber - 1) + " lines in the poem.");

            // Commentary.

            var page = 56;
            var lineOrLinesRegex = "(?:Line (\\d+)|Lines (\\d+)-(\\d+)):.*";
            var between_lines_regex = new RegExp(
              lineOrLinesRegex + "([\\s\\S]*?)(" + lineOrLinesRegex + "[\\s\\S]*)",
            );
            var scrollingBuffer = "";
            var lastPageProcessed = page;
            var i = 0;
            while (true) {
              var matches = scrollingBuffer.match(between_lines_regex);
              if (matches === null) {
                if (i >= commentary.length) {
                  break;
                }
                scrollingBuffer += commentary[i++];
                page++;
              } else {
                var lineStart;
                var lineEnd;
                var suffix = "";
                if (matches[1] !== undefined) {
                  // If reference to a single line, set lineEnd = lineStart.
                  lineStart = matches[1];
                  lineEnd = matches[1];
                } else if (matches[2] !== undefined && matches[3] !== undefined) {
                  lineStart = matches[2];
                  lineEnd = matches[3];
                }
                if (nodeMap.get(`N${lineStart}`) !== undefined) {
                  suffix = "b";
                }
                node = new Node(
                  NodeType.COMMENTARY,
                  `N${lineStart}${suffix}`,
                  lastPageProcessed,
                  matches[4],
                  lineStart,
                  lineEnd,
                );
                nodeMap.set(node.id, node);
                nonPoemNodes.push(node);
                commentaryNodes.push(node);
                // Debugging:
                // console.log("Created " + node.id + ".");
                scrollingBuffer = matches[5];
                lastPageProcessed = page;
              }
            }

            // TODO(P2): Assert number of notes; manually count in book.

            // Poem, this time grouped by ranges with or without commentary.

            var currentLine = 1;
            for (let node of commentaryNodes) {
              var lineStart = node.lineStart;
              var lineEnd = node.lineEnd;
              if (node.id.substr(-1) == "b") {
                console.log("NEED TO FIX b NODES!!!");
                // TODO(P0) - but actually we don't wanna skip, just need to handle
                continue;
              }
              if (lineStart > currentLine) {
                // Next note is beyond current line; create node for non-commentary group.
                node = new Node(
                  NodeType.POEM_GROUP,
                  `G${currentLine}`,
                  poemLineNodes[currentLine].page,
                  poemLines.splice(currentLine, lineStart).join("\n"),
                  currentLine,
                  lineStart - 1,
                );
                nodeMap.set(node.id, node);
                poemGroupNodes.push(node);
                // Debugging:
                // console.log("Created " + node.id + ".");
              }
              // Create node for commentary group.
              node = new Node(
                NodeType.POEM_GROUP,
                `G${lineStart}`,
                poemLineNodes[lineStart].page,
                poemLines.splice(lineStart, lineEnd + 1).join("\n"),
                lineStart,
                lineEnd,
              );
              nodeMap.set(node.id, node);
              poemGroupNodes.push(node);
              // Debugging:
              // console.log("Created " + node.id + ".");
              currentLine = lineEnd + 1;
            }

            // Poem, this time by cantos. Do manually; easiest.

            // TODO: Refactor.
            node = new Node(
              NodeType.POEM_CANTO,
              `C1`,
              poemLineNodes[1].page,
              poemLines.splice(1, 167).join("\n"),
              1,
              166,
            );
            nodeMap.set(node.id, node);
            poemCantosNodes.push(node);

            node = new Node(
              NodeType.POEM_CANTO,
              `C2`,
              poemLineNodes[1].page,
              poemLines.splice(167, 501).join("\n"),
              167,
              166,
            );
            nodeMap.set(node.id, node);
            poemCantosNodes.push(node);

            node = new Node(
              NodeType.POEM_CANTO,
              `C3`,
              poemLineNodes[1].page,
              poemLines.splice(501, 886).join("\n"),
              501,
              885,
            );
            nodeMap.set(node.id, node);
            poemCantosNodes.push(node);

            node = new Node(
              NodeType.POEM_CANTO,
              `C4`,
              poemLineNodes[1].page,
              poemLines.splice(885, 1001).join("\n"),
              885,
              1000,
            );
            nodeMap.set(node.id, node);
            poemCantosNodes.push(node);

            // For debugging; uncomment and change regex to find a page.
            // for (canto of [cantoOne, cantoTwo, cantoThree, cantoFour]) {
            //   for (page of canto) {
            //     if (/headlights/.test(page)) {
            //       console.log(page);
            //     }
            //   }
            // }

            // Had to move some constants here.

            const purple = "rgb(148, 103, 189)";
            const blue = "rgb(31, 119, 180)";
            const green = "rgb(44, 160, 44)";
            const yellow = "rgb(255, 214, 51)";
            const orange = "rgb(255, 127, 14)";
            const red = "rgb(214, 39, 40)";

            var debug_mode = false;
            var suspicious_refs = 0;

            var re_line_range = "\\b(1000|\\d{1,3})\\b(?: ?- ?\\b(1000|\\d{1,3})\\b)?";
            var re_compound_line_range =
              re_line_range +
              "(?:(?: and|,) " +
              re_line_range +
              "(?:(?:, and|,) " +
              re_line_range +
              ")?)?";
            var direct_reference_regex = "note[s]? to(?: line[s]?)? " + re_compound_line_range;
            var direct_ref_with_rest_regex =
              "([\\s\\S]*?)" + direct_reference_regex + "([\\s\\S]*)";
            var indirect_ref_regex = "line[s]? " + re_compound_line_range;
            var indirect_ref_with_rest_regex = "([\\s\\S]*?)" + indirect_ref_regex + "([\\s\\S]*)";
            var foreword_ref_regex = "((?:my|see|in the)\\s+foreword)";
            var foreword_ref_with_rest_regex = "([\\s\\S]*?)" + foreword_ref_regex + "([\\s\\S]*)";

            // The part that takes the longest time to load by far is not parsing out the
            // commentary nodes themselves but parsing each for references to lines and other nodes.
            // So we will base the loading bar on this loop. This has an unfortunate side-effect.
            // We need to call window.requestAnimationFrame(...) after each update to the loading
            // progress or the SVG won't update; doing so requires using a callback-based "loop"
            // rather than a simple for loop. But that's all it is—a loop.

            svg_force_directed
              .transition()
              .duration(750)
              .call(zoom.transform, d3.zoomIdentity.translate(50, 50).scale(0.5));

            let loading_index = 0;
            function parseNonPoemNodeForReferences(loading_index) {
              if (loading_index >= nonPoemNodes.length) return;

              let nonPoemNode = nonPoemNodes[loading_index];

              z.attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .append("circle")
                .datum({
                  type: nonPoemNode.type,
                  id: nonPoemNode.id,
                  name: nonPoemNode.id,
                  wordcount: nonPoemNode.wordcount,
                  source_node: nonPoemNode,
                })
                //.join("circle")
                //.attr("cx", 20 * loading_index++)
                .attr("cx", 20 * loading_index++)
                .attr("cy", 0)
                .attr("r", (d) => Math.max(10, Math.sqrt(d.wordcount)))
                .attr("fill", (d) => mapTypeToColor(d.type))
                .each(function (d) {
                  d.source_node.d3_force_directed_node_selected = d3.select(this);
                });

              if (debug_mode) console.log(`Finding references in ${nonPoemNode.id}...`);
              var text = nonPoemNode.text.replace(/\s+/g, " ");
              while (true) {
                var matches = text.match(new RegExp(direct_ref_with_rest_regex, "i"));
                if (matches === null) {
                  break;
                }
                if (debug_mode) {
                  console.log(`Direct reference:
                    2:${matches[2]},
                    3:${matches[3]},
                    4:${matches[4]},
                    5:${matches[5]},
                    6:${matches[6]},
                    7:${matches[7]}`);
                }
                if (matches[2] !== undefined) {
                  nonPoemNode.direct_references.push("N" + matches[2]);
                }
                if (matches[4] !== undefined) {
                  nonPoemNode.direct_references.push("N" + matches[4]);
                }
                if (matches[6] !== undefined) {
                  nonPoemNode.direct_references.push("N" + matches[6]);
                }
                // Remove just the direct reference and keep the rest.
                text = matches[1] + " xxx " + matches[8];
              }
              while (true) {
                var matches = text.match(new RegExp(indirect_ref_with_rest_regex, "i"));
                if (matches === null) {
                  break;
                }
                if (debug_mode) {
                  console.log(`Indirect reference:
                    2:${matches[2]},
                    3:${matches[3]},
                    4:${matches[4]},
                    5:${matches[5]},
                    6:${matches[6]},
                    7:${matches[7]}`);
                }
                if (matches[2] !== undefined) {
                  nonPoemNode.indirect_references.push("N" + matches[2]);
                }
                if (matches[4] !== undefined) {
                  nonPoemNode.indirect_references.push("N" + matches[4]);
                }
                if (matches[6] !== undefined) {
                  nonPoemNode.indirect_references.push("N" + matches[6]);
                }
                // Remove just the indirect reference and keep the rest.
                text = matches[1] + " xxx " + matches[8];
              }
              while (true) {
                var matches = text.match(new RegExp(foreword_ref_with_rest_regex, "i"));
                if (matches === null) {
                  break;
                }
                if (debug_mode) {
                  console.log(`Foreword reference:
                    2:${matches[2]}`);
                }
                if (matches[2] !== undefined) {
                  nonPoemNode.direct_references.push("F");
                }
                // Remove just the indirect reference and keep the rest.
                text = matches[1] + " xxx " + matches[3];
              }
              // Flag any other occurrence of line numbers for manual review.
              var re_suspicious = `(?:${re_line_range}|[Ff]oreword)`;
              var suspicious_matches = [...text.matchAll(re_suspicious)];
              if (suspicious_matches.length > 0) {
                console.log(`Suspicious numbers in ${nonPoemNode.id}:`);
                console.log(suspicious_matches);
              }
              suspicious_refs += suspicious_matches.length;
              // Inspect a certain node.
              // if (nonPoemNode.id == "N42") {
              //   console.log("Inspecting:");
              //   console.log(nonPoemNode.text.replace(/\s+/g, " "));
              // }

              requestAnimationFrame(() => parseNonPoemNodeForReferences(loading_index + 1));
            }

            requestAnimationFrame(() => parseNonPoemNodeForReferences(loading_index));

            return;

            console.log("Found " + suspicious_refs + " suspicious references.");

            // There's a case where Nabokov refers to the notes for line 664, meaning to refer to the
            // notes for line 662. Create a map that refers such intermediate references to the
            // nearest note for a previous line.
            for (let i = 0; i < commentaryNodes.length - 1; i++) {
              for (
                let j = commentaryNodes[i].lineStart;
                j < commentaryNodes[i + 1].lineStart;
                j++
              ) {
                lineToNodeMap.set("N" + j, commentaryNodes[i]);
              }
            }
            lineToNodeMap.set("F", nodeMap.get("F"));
            lineToNodeMap.set("N1000", nodeMap.get("N1000"));

            //////////////////////////////////////////////////////////////////////////////////////////
            // Prepare D3.js nodes. (But we will use a copy of them on the actual SVG.)
            //////////////////////////////////////////////////////////////////////////////////////////

            var d3_node_blueprints = [];
            var d3_link_blueprints = [];

            for (let nonPoemNode of nonPoemNodes) {
              d3_node_blueprints.push({
                type: nonPoemNode.type,
                id: nonPoemNode.id,
                name: nonPoemNode.id,
                wordcount: nonPoemNode.wordcount,
                source_node: nonPoemNode,
              });
            }

            for (let cantoNode of poemCantosNodes) {
              d3_node_blueprints.push({
                type: cantoNode.type,
                id: cantoNode.id,
                name: cantoNode.id,
                wordcount: cantoNode.wordcount,
                source_node: cantoNode,
              });
            }

            for (let nonPoemNode of nonPoemNodes) {
              for (let ref of nonPoemNode.direct_references) {
                if (!nodeMap.has(ref)) {
                  if (lineToNodeMap.has(ref)) {
                    ref = lineToNodeMap.get(ref).id;
                  } else {
                    continue;
                  }
                }
                d3_link_blueprints.push({
                  source: nonPoemNode.id,
                  target: ref,
                  value: 1,
                  type: ReferenceType.DIRECT,
                });
              }
              for (let ref of nonPoemNode.indirect_references) {
                if (!nodeMap.has(ref)) {
                  if (lineToNodeMap.has(ref)) {
                    ref = lineToNodeMap.get(ref).id;
                  } else {
                    continue;
                  }
                }
                d3_link_blueprints.push({
                  source: nonPoemNode.id,
                  target: ref,
                  value: 1,
                  type: ReferenceType.INDIRECT,
                });
              }
            }

            //////////////////////////////////////////////////////////////////////////////////////////
            // Variables and functions for graph interactivity (both graphs).
            //////////////////////////////////////////////////////////////////////////////////////////

            function mapTypeToColor(type) {
              switch (type) {
                case NodeType.FOREWORD:
                  return green;
                case NodeType.POEM_CANTO:
                  return red;
                case NodeType.POEM_GROUP:
                  return green;
                case NodeType.POEM_LINE:
                  return green;
                case NodeType.COMMENTARY:
                  return blue;
                default:
                  return "#000000";
              }
            }

            var dfs_ordering = [];

            function highlight_nodes_upto(id) {
              // Can optimize by caching the current selected and only re-coloring the difference.
              for (let i = 0; i <= nodeMap.get(id).dfs_ordering; i++) {
                dfs_ordering[i].d3_custom_layout_node_selected.attr("fill", (d) => purple);
                dfs_ordering[i].d3_force_directed_node_selected.attr("fill", (d) => purple);
              }
              for (let i = nodeMap.get(id).dfs_ordering + 1; i < dfs_ordering.length; i++) {
                dfs_ordering[i].d3_custom_layout_node_selected.attr("fill", (d) =>
                  mapTypeToColor(d.type),
                );
                dfs_ordering[i].d3_force_directed_node_selected.attr("fill", (d) =>
                  mapTypeToColor(d.type),
                );
              }
            }

            //////////////////////////////////////////////////////////////////////////////////////////
            // Scope force-directed graph.
            //////////////////////////////////////////////////////////////////////////////////////////

            {
              // The force simulation mutates links and nodes, so create a copy
              // so that re-evaluating this cell produces the same result.
              const d3_nodes = d3_node_blueprints.map((d) => ({ ...d }));
              const d3_links = d3_link_blueprints.map((d) => ({ ...d }));

              // Link the source node to this node.
              for (let n of d3_nodes) {
                n.source_node.d3_force_directed_node = n;
              }

              // Specify the dimensions of the chart.
              const width = 740; // TODO: Where did these dimensions come from?
              const height = 512;

              // Create a simulation with several forces.
              const simulation = d3
                .forceSimulation(d3_nodes)
                .force(
                  "link",
                  d3.forceLink(d3_links).id((d) => d.id),
                )
                .force("charge", d3.forceManyBody().strength(-5))
                .force("collide", d3.forceCollide(80).iterations(50))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .on("tick", ticked);

              // const z = svg_force_directed
              //   .call(
              //     d3.zoom().on("zoom", function () {
              //       z.attr("transform", d3.zoomTransform(this));
              //     }),
              //   )
              //   .append("g");

              z.append("defs")
                .append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 20)
                .attr("refY", 0)
                .attr("markerWidth", 8)
                .attr("markerHeight", 8)
                .attr("orient", "auto")
                .append("svg:path")
                .attr("d", "M0,-5L10,0L0,5");

              const d3_link = z
                .selectAll()
                .data(d3_links)
                .join("line")
                .attr("marker-end", "url(#arrow)")
                .attr("stroke-width", (d) => {
                  switch (d.type) {
                    case ReferenceType.DIRECT: {
                      return "3";
                      break;
                    }
                    case ReferenceType.INDIRECT: {
                      return "1";
                      break;
                    }
                  }
                })
                .attr("stroke", (d) => {
                  switch (d.type) {
                    case ReferenceType.DIRECT: {
                      return "#333";
                      break;
                    }
                    case ReferenceType.INDIRECT: {
                      return "#999";
                      break;
                    }
                  }
                })
                .attr("stroke-opacity", 0.6);

              // const d3_node = z
              //   .attr("stroke", "#fff")
              //   .attr("stroke-width", 1.5)
              //   .selectAll()
              //   .data(d3_nodes)
              //   .join("circle")
              //   .attr("r", (d) => Math.max(10, Math.sqrt(d.wordcount)))
              //   .attr("fill", (d) => mapTypeToColor(d.type))
              //   .each(function (d) {
              //     d.source_node.d3_force_directed_node_selected = d3.select(this);
              //   });

              d3_node.append("title").text((d) => d.id);

              // Add a drag behavior.
              d3_node.call(
                d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended),
              );

              // Set the position attributes of links and nodes each time the simulation ticks.
              function ticked() {
                d3_link
                  .attr("x1", (d) => d.source.x)
                  .attr("y1", (d) => d.source.y)
                  .attr("x2", (d) => d.target.x)
                  .attr("y2", (d) => d.target.y);

                d3_node.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
              }

              // Reheat the simulation when drag starts, and fix the subject position.
              function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
              }

              // Update the subject (dragged node) position during drag.
              function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
              }

              // Restore the target alpha so the simulation cools after dragging ends.
              // Unfix the subject position now that it’s no longer being dragged.
              function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
              }
            }

            //////////////////////////////////////////////////////////////////////////////////////////
            // Scope custom layout graph.
            //////////////////////////////////////////////////////////////////////////////////////////

            {
              let d3_nodes = [];
              let d3_links = [];

              for (let nonPoemNode of nonPoemNodes) {
                d3_nodes.push({
                  type: nonPoemNode.type,
                  id: nonPoemNode.id,
                  name: nonPoemNode.id,
                  source_node: nonPoemNode,
                  wordcount: nonPoemNode.wordcount,
                });
              }

              // Link the source node to this node.
              for (let n of d3_nodes) {
                n.source_node.d3_custom_layout_node = n;
              }

              const SPACING_X = 50;
              const SPACING_LVL = 100;
              // Ideal columns per wrap determined by trial-and-error.
              const WRAP_AFTER_WIDTH = 1050;
              let currentXOffset = 0;
              let currentWrapYOffset = 0;
              let previousWrap = 0; // Not strictly needed but easier to understand.
              let previousLvl = -1;
              let currentWrapMaxLvl = 0;
              let currentChainMaxRadius = 0;
              let dfs_order = 0; // Counts a node's order in the DFS.
              let stack = [];
              let visited = new Map();
              let debug_breaker = false;
              for (let nonPoemNode of nonPoemNodes) {
                if (debug_breaker) break;
                if (visited.get(nonPoemNode.id) !== undefined) {
                  continue;
                }
                // Queue of triplets: (1) parent node (or null), (2) child node, (3) level.
                stack.push([null, nonPoemNode, 0]);
                while (stack.length > 0) {
                  if (debug_breaker) break;
                  let [parentNode, currentNode, currentLvl] = stack.pop();
                  if (visited.get(currentNode.id) !== undefined) {
                    continue;
                  }
                  if (currentLvl > currentWrapMaxLvl) {
                    // Needed to determine by how much to Y-offset the next wrap.
                    currentWrapMaxLvl = currentLvl;
                  }
                  let currentWrap = Math.floor(currentXOffset / WRAP_AFTER_WIDTH);
                  if (currentWrap > previousWrap) {
                    currentXOffset = 0;
                    currentWrapYOffset += (currentWrapMaxLvl + 1) * SPACING_LVL;
                    currentWrapMaxLvl = 0;
                    previousLvl = -1;
                  }
                  previousWrap = currentWrap;
                  if (currentLvl > previousLvl) {
                    currentNode.d3_custom_layout_node.cx = currentXOffset;
                    currentNode.d3_custom_layout_node.cy =
                      currentWrapYOffset + currentLvl * SPACING_LVL;
                  } else {
                    currentXOffset += currentChainMaxRadius + SPACING_X;
                    currentNode.d3_custom_layout_node.cx = currentXOffset;
                    currentNode.d3_custom_layout_node.cy =
                      currentWrapYOffset + currentLvl * SPACING_LVL;
                  }
                  if (parentNode !== null) {
                    d3_links.push({
                      source: parentNode.d3_custom_layout_node,
                      target: currentNode.d3_custom_layout_node,
                      value: 1,
                      type: ReferenceType.DIRECT,
                    });
                  }
                  // This is used to look up where in the dfs_ordering array a node is, e.g. on click.
                  currentNode.dfs_ordering = dfs_ordering.length;
                  // This is an array of nodes in DFS order for fast iteration, e.g. for highlighting.
                  dfs_ordering.push(currentNode);
                  visited.set(currentNode.id, true);
                  previousLvl = currentLvl;
                  for (let childNodeId of currentNode.direct_references.reverse()) {
                    if (debug_breaker) break;
                    let n = lineToNodeMap.get(childNodeId);
                    // if (n.id == "N747") debug_breaker = true;
                    stack.push([currentNode, n, currentLvl + 1]);
                  }
                }
              }

              // Specify the dimensions of the chart.
              const width = 740;
              const height = 512;

              const svg = d3
                .create("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("viewBox", [0, 0, width, height])
                .attr("style", "width: 100%; height: 512px;");

              const z = svg
                .call(
                  d3.zoom().on("zoom", function () {
                    z.attr("transform", d3.zoomTransform(this));
                  }),
                )
                .append("g");

              // The links are drawn before the nodes because D3 follows creation order for z-index.
              const d3_link = z
                .selectAll()
                .data(d3_links)
                .join("line")
                .attr("stroke-width", 1)
                .attr("stroke", "#999")
                .attr("x1", (d) => d.source.cx)
                .attr("y1", (d) => d.source.cy)
                .attr("x2", (d) => d.target.cx)
                .attr("y2", (d) => d.target.cy)
                .attr("stroke-opacity", 0.6);

              const d3_node = z
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll()
                .data(d3_nodes)
                .join("circle")
                .attr("cx", (d) => d.cx)
                .attr("cy", (d) => d.cy)
                .attr("r", (d) => Math.max(10, Math.sqrt(d.wordcount)))
                .attr("fill", (d) => mapTypeToColor(d.type))
                .each(function (d) {
                  d.source_node.d3_custom_layout_node_selected = d3.select(this);
                });

              const tooltip = d3
                .select("body")
                .append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

              d3_node
                .on("mouseover", function (event, d) {
                  tooltip.transition().duration(200).style("opacity", 0.9);
                  tooltip
                    .html(d.id)
                    .style("left", event.pageX + 5 + "px")
                    .style("top", event.pageY - 28 + "px");
                })
                .on("mouseout", function (d) {
                  tooltip.transition().duration(500).style("opacity", 0);
                });

              d3_node.on("mousedown", function (event, d) {
                highlight_nodes_upto(d.source_node.id);
              });

              document.getElementById("custom-layout-graph").append(svg.node());

              highlight_nodes_upto("N130");
            }
          });
      });
    </script>

    <!-- Markdown -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
      var content = document.getElementById("content");
      content.innerHTML = marked.parse(content.innerHTML);
    </script> -->
    <!-- CSS/LESS -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/less.js/4.2.0/less.min.js"
      integrity="sha512-y2WgniVReZzVhOotEigpCJTu6Q6yGN0o8ezFzgS21PlWM1rqfSv7UPraV+IEDO9ljsli47Kr/toVOsukTVynuw=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <!-- Hides unstyled page until Markdown and LESS finishes processing. -->
    <script>
      window.addEventListener("load", function () {
        document.getElementsByTagName("html")[0].style.visibility = "visible";
      });
    </script>
  </body>
</html>
